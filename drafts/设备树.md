
# 设备树，覆盖，以及参数

数梅派最新内核以及固件包括 Raspbian 和 NOOBS，现在均默认使用设备树（Device Tree）管理资源分配和模块加载。此方式用于减轻多驱动对系统资源的争夺，以及让 HAT 模块可自动配置。

当前的实现方式不是纯粹的设备树系统实现方式——依然存在一些用于创建平台设备的板级支持代码——但如 I2C，I2S，SPI 的外部接口，以及使用这些接口的语音设备，现在确认使用扁平设备树（也称 Flattened Device Tree 或 Device Tree Blob）在系统中创建设备实例。DTB（或 FDT）由启动加载器传递给内核。

使用设备树系统带来的主要变化是，从以前的每个模块都是开启状态依赖模块黑名单机制来管理多驱动冲突，到现在的只开启 DTB 所定义的模块其余关闭。为了继续使用外部接口和相应的外设，你需要在 `config.txt` 中添加一些新的设置。关于设置的完成描述在[第三部分](#第三部分在树梅派中使用设备树)，如下是一些示例：

```
# Uncomment some or all of these lines to enable the optional hardware interfaces
#dtparam=i2c_arm=on
#dtparam=i2s=on
#dtparam=spi=on

# Uncomment one of these lines to enable an audio interface
#dtoverlay=hifiberry-amp
#dtoverlay=hifiberry-dac
#dtoverlay=hifiberry-dacplus
#dtoverlay=hifiberry-digi
#dtoverlay=iqaudio-dac
#dtoverlay=iqaudio-dacplus
#dtoverlay=audioinjector-wm8731-audio

# Uncomment this to enable the lirc-rpi module
#dtoverlay=lirc-rpi

# Uncomment this to override the defaults for the lirc-rpi module
#dtparam=gpio_out_pin=16
#dtparam=gpio_in_pin=17
#dtparam=gpio_in_pull=down
```

## 第一部分：设备树

对系统中硬件的描述被称为设备树。它应包含 CPU 名称，内存配置，以及所有外设（内部的或外部的）。在设备树中不应出现对软件的描述信息，尽管在设备树中列出硬件模块通常会使得系统加载相应驱动。设备树也应是独立于操作系统的，所以 Linux 特有的信息也不应该出现在设备树中。

设备树使用由节点构成的层级结构来描述硬件配置。每个节点可以包含属性和子节点。属性是带名称的字节数组，其可以包含字符串、数字（大端）、任意序列的字节，以及它们的任意组合。把设备树和文件系统进行类比的话，节点便是文件系统中的目录，属性便是文件系统中的文件。节点和属性在设备树中的位置可以用路径来描述，用斜杠作为分隔符，单个斜杠（`/`）表示根。

### 1.1：DTS 基本语法

设备树使用设备树源（DTS）的文本形式来描述并且保存在以 `.dts` 结尾的文件中。DTS 使用和 C 语言很类似的语法，分组用花括号，结束用分号。值得注意的是 DTS 要求在结束的花括号之后也要有分号：想象一下 C 语言中的`结构体`而不是`函数`。编译 DTS 文件得到的二进制文件被称为扁平设备树（FDT）或 Device Tree Blob（DTB），保存在 `.dtb` 文件中。

下面是 `.dts` 格式的设备树示例：

```
/dts-v1/;
/include/ "common.dtsi";

/ {
    node1 {
        a-string-property = "A string";
        a-string-list-property = "first string", "second string";
        a-byte-data-property = [0x01 0x23 0x34 0x56];
        cousin: child-node1 {
            first-child-property;
            second-child-property = <1>;
            a-string-property = "Hello, world";
        };
        child-node2 {
        };
    };
    node2 {
        an-empty-property;
        a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */
        child-node1 {
            my-cousin = <&cousin>;
        };
    };
};

/node2 {
    another-property-for-node2;
};
```

这棵树包含如下信息：

* 必备的头信息：`/dts-v1/`
* 包含其他 DTS 文件，这类文件一般命名为 `.dtsi` 类似于 C 语言的 `.h` 文件，关于 `/include/` 后面有详细介绍。
* 根节点：`/`
* 多个子节点：`node1` 和 `node2`
* node1 包含一些子节点：`child-node1` 和 `child-node2`
* 标签（cousin）以及引用这个标签（&consin）：后面有对标签以及引用的介绍。
* 各种属性分布在整个树中。
* 重复节点（`/node2`）—— 参考后面介绍 `/include/` 的一节。

属性是简单的“键值对”其中“值”既能为空也能是任意的字节流。数据类型没有编码到数据结构中，但设备树源文件中存在一些基本数据表示方式。

用双引号表示字符串（以 NUL 结束）：

```
string-property = "a string";
```

用三角括号界定单元格，单元格是 32-bit 无符号整型数：

```
cell-property = <0xbeef 123 0xabcd1234>;
```

方括号里是任意的字节数据，用16进制表示：

```
binary-property = [01 23 45 67 89 ab cd ef];
```

不同表示方式的数据可以用逗号连接：

```
mixed-property = "a string", [01 23 45 67], <0x12345678>;
```

用逗号还能创建字符串列表：

```
string-list = "red fish", "blue fish";
```

### 1.2：关于 /include/

使用 `/include/` 助记符会产生简单的文本包含效果，和 C 语言的 `#include` 助记符很像，但是设备树编译器的一个特性导致其有不同的使用模式。给定命名的节点，潜在的也有一个绝对路径，相同的节点可以多次出现在 DTS 文件（或其包含文件）中。当这种情况发生时，节点和属性会组合到一起，属性会被插入或者覆盖（后面出现的值覆盖之前的值）。

再上面的例子中，第二次出现的 `/node2` 会使原来的 `node2` 添加一个新的属性：

```
/node2 {
    an-empty-property;
    a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */
    another-property-for-node2;
    child-node1 {
        my-cousin = <&cousin>;
    };
};
```

这使得 `.dtsi` 文件可以覆盖一颗树的多个地方，或者为一颗树提供默认值。

### 1.3：标签和引用

在设备树的一处能引用其另一部分是很必要的，可通过下面四种方式来实现：

1. 路径字符串

    路径具有自解释特性，和文件系统类似—— `/soc/i2s@7e203000` 是 BCM2835 和 BCM2836 中 I2S 设备的的完整路径。注意，尽管构建一个属性的路径很容易（如，`/soc/i2s@7e203000/status`），标准应用编程接口不这样做，而是先找到节点，再通过节点选择属性。

2. phandles

    A phandle is a unique 32-bit integer assigned to a node in its phandle property. For historical reasons, you may also see a redundant, matching linux,phandle. phandles are numbered sequentially, starting from 1; 0 is not a valid phandle. They are usually allocated by the DT compiler when it encounters a reference to a node in an integer context, usually in the form of a label (see below). References to nodes using phandles are simply encoded as the corresponding integer (cell) values; there is no markup to indicate that they should be interpreted as phandles, as that is application-defined.

3. 标签

    和 C 语言的标签给某处代码一个名称类似，设备树标签给层级结构中的节点一个名称。编译器拿到对标签的引用，当在字符串上下文（`&node`）中时将其转换成路径，在整数上下文（`<&node>`）中将其转换成 phandle，在编译之后的文件中不会出现原来的标签。注意标签没有结构，它们只是全局命名空间中的一个代号。

4. 别名

    别名和标签类似，不同的是它会以索引的形式出现在 FDT 中。别名存在 `/aliases` 节点的属性中，每个属性将一个别名映射到路径字符串。尽管别名节点会出现源码中，路径字符串通常是以标签引用的形式出现而不是完整的路径。设备树应用编程接口解析节点路径时，一般先检查路径的第一个字符，如果路径不以斜杠开始则将其作为别名处理——用 `/aliases` 表转换为路径。

### 1.4：设备树语义

如何构建一颗设备树以及如何利用它来获取部分硬件的配置是个很大很复杂的主题，这方面有很多可参阅材料，本文后面也会列出一些信息，但是有几点很值得在这里提及：

`compatible` 属性在硬件描述和驱动软件之间建立起连接。当操作系统遇到带 `compatible` 属性的节点时，会在数据库中为其查找最匹配的设备驱动。在 Linux 中这个过程会使得相应标记并没有被加入黑名单的驱动模块自动加载并提供给系统。

`status` 属性指定一个设备是开启还是关闭。如果 `status` 的值是 `ok`、`okay` 或者留空则表示设备开启，设备关闭只能用 `disabled` 表示。在 `.dtsi` 文件中声明一个 `status` 为 `disabled` 的设备会很有帮助。从这个 `.dtsi` 文件衍生出来的配置可以在需要的时候将这个设备的状态设置为 `okay`。

## 第二部分：设备树的覆盖

现代 SoC（System on Chip）是一个非常复杂的设备，用于完整描述此类设备的设备树文件可能长达几百上千行源码。更进一步，当把 SoC 放到开发板上与其他组件一起协同工作时，就会产生更多源码。为了使设备树便于管理，特别是当系统存在共享组件时，将相同共同部分放入 `.dtsi` 文件然后供多个 `.dts` 文件包含。

但当遇到像树梅派这样支持可选插件（如 HAT）问题会进一步放大。比如，每一种可能的配置都需要一个设备树来描述，当将各种基本硬件（如型号 A，B，A+，B+）以及小型插件（能共存并且只使用几个 GPIO 管脚的设备）考虑进来之后，可能出现的配置组合数量就会快速增加。

我们所需的是一种方式——用不完整的树（partial）来描述可选组件，然后在基础设备树上添加这些可选部分来构建一个完整的树。这是可以实现的，这些可选部分叫做“覆盖”。

### 2.1：片段

设备树“覆盖”由一系列片段组成，每一个片段标的一个节点或者子节点。尽管概念貌似简单，但其语法却看着比较陌生：

```
// Enable the i2s interface
/dts-v1/;
/plugin/;

/ {
    compatible = "brcm,bcm2708";

    fragment@0 {
        target = <&i2s>;
        __overlay__ {
            status = "okay";
        };
    };
};
```

`compatible` 字段指定这段定义是针对 BCM2708 的，它是 BCM2835 的基础架构。对于 BCM2836 可以使用 `"brcm,bcm2709"` 作为 `compatible` 字段的值，除非你针对的是 ARM CPU 的特性，否则两种架构没有区别，因此直接使用 `"brcm,bcm2708"` 是可以接受的。紧接着就是我们的第一次片段（仅在次例中）。片段从零开始按顺序排列。如果没有遵循此约束可能会导致部分片段丢失。

片段由两部分组成：一个 `target` 属性，指定被覆盖的节点；另一个是 `__overlay__` 本身，是添加到指定节点的内容。上面例子可以理解为如下：

```
/dts-v1/;

/ {
    compatible = "brcm,bcm2708";
};

&i2s {
    status = "okay";
};
```

将如上片段和标准树莓派基础设备树（如，`bcm2708-rpi-b-plus.dtb`）整合到一起（此片段在标准树莓派基础设备树之后加载）的结果是，将 I2S 接口状态变为 `okay` 使得其处于开启状态。但当你试着编译这次“覆盖”时：

```
dtc -I dts -O dtb -o 2nd.dtbo 2nd-overlay.dts
```

会得到错误提示：

```
Label or path i2s not found
```

这不会使人太惊讶，因为此时并没有对基础 `.dtb` 或者 `.dts` 文件的引用来使得编译器可以找到 `i2s` 标签。

用刚刚的例子再试一次，这次加上 `-@` 选项开启允许存在未解析引用：

```
dtc -@ -I dts -O dtb -o 1st.dtbo 1st-overlay.dts
```

如果 `dtc` 对第三行报错，表明编译工具缺少使覆盖正确工作的拓展。运行 `sudo apt-get install device-tree-compiler` 然后再次尝试，此时编译能够成功。注意，内核树中同样提供合适的编译器 `scripts/dtc/dtc`，当 `make` `dtbs` 构建时会使用。

```
make ARCH=arm dtbs
```

将 `dtb` 文件的内容 `dump` 出来看看编译器生成了什么：

```
$ fdtdump 1st.dtbo

/dts-v1/;
// magic:           0xd00dfeed
// totalsize:       0x106 (262)
// off_dt_struct:   0x38
// off_dt_strings:  0xe8
// off_mem_rsvmap:  0x28
// version:         17
// last_comp_version:    16
// boot_cpuid_phys: 0x0
// size_dt_strings: 0x1e
// size_dt_struct:  0xb0

/ {
    compatible = "brcm,bcm2708";
    fragment@0 {
        target = <0xdeadbeef>;
        __overlay__ {
            status = "okay";
        };
    };
    __fixups__ {
        i2s = "/fragment@0:target:0";
    };
};
```

在大量针对文件结构的描述信息之后就是片段了。仔细观察不难发现，前面例子中的 `&i2s` 成了现在的 `0xdeadbeef`，这表明有奇怪的事情发现了（!-_-）。在片段之后出现了一个新的节点 `__fixups__`。这个节点中包含了一列属性将未解析标签映射到指向单元格的路径，此单元格中保存着目标节点的 `phandle`，片段用这个 `phandle` 向目标节点打补丁。在此例中路径指向 `target` 的 `0xdeadbeef` 值，但片段可以包含其他未解析的引用因此需要添加额外的信息。

如果你写了一些比较复杂的片段，编译器会产生两个额外的节点：`__local_fixups__` 和 `__symbols__`。如果片段中的任意节点存在 `phandle` 那么前者就是必须的，因为执行整合操作的程序必须保证 `phandle` 号码是独一无二却按顺序排列的。后者则是处理未解析标签的关键所在。

1.3 节讲到“原始标签不会出现在编译之后的结果中”，但当开启了 `-@` 选项此说法就不成立了。相反，每个标签都会以属性形式出现在 `__symbols__` 节点中，将标签映射到路径，就像 `aliases` 节点一样。在解析标签时他们的作用机制也是相似的，当缺少 `__symbols__` 节点时树莓派的启动加载器会搜索 `aliases` 节点。此规则很有用，通过在 `aliases` 中提供足够的信息可以使用旧版的 `dtc` 来构建 DTB 文件。

*更新*：[动态设备树](#35动态设备树)在内核方面的支持要求在覆盖中有不同格式的 `__local_fixups__`。为了避免新风格和就风格的覆盖同时存在而产生问题，以及匹配其他用法，从4.4往后用“name.dtbo”来代替以前的“name-overlay.dtb”命名方式。覆盖因该只用名称引用，加载它们的固件以及工具负责添加相应的后缀。比如：

```
dtoverlay=awesome-overlay      # 错误方式
dtoverlay=awesome              # 正确方式
```

### 2.2：设备树参数

为了避免对大量设备树覆盖的需求以及减少外设用户对 DTS 文件修改的需要，树莓派启动加载器提供了一个新的功能——设备树参数。这就允许通过使用命名参数对 DT 进行细微的改动，就和内核模块通过 `modprobe` 以及内核命令行接受参数类似。参数可通过基础设备树以及覆盖（包括 HAT 覆盖）对外暴露。

参数通过在 DTS 文件的根节点中添加一个 `__overrides__` 节点来定义。节点中的属性名称是选择的参数名称，值是由目标节点的 `phanlde` 组成的序列（对标签的引用），以及一个字符串用来指示目标的属性（支持 `string`、`integer(call)`、`boolean`）。

#### 2.2.1：字符串参数

字符串参数的申明如下：

```
name = <&label>,"property";
```

其中 `label` 和 `property` 用合适的值替换。字符串参数能使得其目标属性拓展、缩减或者创建。

注意 `status` 属性需要特殊对待，`非零的值`/`true`/`yes`/`on` 都会被转换成 `"okay"`，而 `zero`/`false`/`no`/`off` 则被转换成 `"disabled"`。

#### 2.2.2：整型参数

整型参数的申明如下：

```
name = <&label>,"property.offset"; // 8-bit
name = <&label>,"property;offset"; // 16-bit
name = <&label>,"property:offset"; // 32-bit
name = <&label>,"property#offset"; // 64-bit
```

其中 `label`，`property` 和 `offset` 用合适的值替换。`offset` 是相对于属性开始位置的偏移字节数（默认10进制），`offset` 之前的分隔符指示参数的大小。和整型参数早期实现不同的是，其可以指向不存在的属性，或偏移到已存在属性的结尾之外。

#### 2.2.3：布尔参数

设备树将布尔值编码成零长度的属性，如果属性出现则表示为 `true`，否则为 `false`。定义方式如下：

```
boolean_property; // 设置 'boolean_property' 的值为 true
```

注意将一个属性的值设置为 `false` 的方法就是不定义它。布尔参数的申明如下：

```
name = <&label>,"property?";
```

其中 `label` 和 `property` 用合适的值替换。布尔参数导致属性被创建或者删除。

#### 2.2.4：覆盖/片段参数

前面介绍的设备树参数机制存在许多限制，这些限制包括无法更改节点名称以及对任意属性写入任意值。一种解除限制的方法是按条件包含或者排除特定的片段。

片段可在最后整合阶段通过将 `__overlay__` 节点重命名为 `__dormant__` 从而被移除。被拓展之后的参数申明语法允许目标 `phandle` 的值为 `0` 来指示其后的字符串包含对片段和覆盖的操作。目前已经实现了四种操作：

```
+<n>    // 开启片段 <n>
-<n>    // 关闭片段 <n>
=<n>    // 开启片段 <n> 如果参数赋值为真，否则关闭
!<n>    // 开启片段 <n> 如果参数赋值为否，否则关闭
```

示例：

```
just_one    = <0>,"+1-2"; // 开启1，关闭2
conditional = <0>,"=3!4"; // 开启3，关闭4 如果值为真，
                          // 否则关闭3，开启4。
```

i2c-mux 覆盖使用了这个技巧。

#### 2.2.5：示例

如下展示了使用参数修改不同类型属性：

```
/ {
	fragment@0 {
		target-path = "/";
		__overlay__ {

			test: test_node {
				string = "hello";
				status = "disabled";
				bytes = /bits/ 8 <0x67 0x89>;
				u16s = /bits/ 16 <0xabcd 0xef01>;
				u32s = /bits/ 32 <0xfedcba98 0x76543210>;
				u64s = /bits/ 64 < 0xaaaaa5a55a5a5555 0x0000111122223333>;
				bool1; // Defaults to true
				       // bool2 defaults to false
			};
		};
	};

	fragment@1 {
		target-path = "/";
		__overlay__ {
			frag1;
		};
	};

	fragment@2 {
		target-path = "/";
		__dormant__ {
			frag2;
		};
	};

    __overrides__ {
		string =      <&test>,"string";
		enable =      <&test>,"status";
		byte_0 =      <&test>,"bytes.0";
		byte_1 =      <&test>,"bytes.1";
		u16_0 =       <&test>,"u16s;0";
		u16_1 =       <&test>,"u16s;2";
		u32_0 =       <&test>,"u32s:0";
		u32_1 =       <&test>,"u32s:4";
		u64_0 =       <&test>,"u64s#0";
		u64_1 =       <&test>,"u64s#8";
		bool1 =       <&test>,"bool1?";
		bool2 =       <&test>,"bool2?";
		only1 =       <0>,"+1-2";
		only2 =       <0>,"-1+2";
		toggle1 =     <0>,"=1";
		toggle2 =     <0>,"=2";
		not1 =        <0>,"!1";
		not2 =        <0>,"!2";
	};
};
```

#### 2.2.6：多目标参数

在某些场景下如果能够对设备树中不同地方同时设置值将会非常方便。与其笨拙地创建多个参数，不如在同一个参数上添加多个目标，如下：

```
    __overrides__ {
        gpiopin = <&w1>,"gpios:4",
                  <&w1_pins>,"brcm,pins:0";
        ...
    };
```

（此例来自于 `w1-gpio` 覆盖）

注意，用一个参数标的不同类型的属性也是可以的。你能将 `"enable"` 参数连接到 `status` 字符串，包含 `0` 或 `1` 的单元格，以及适合的布尔属性。

#### 2.2.7：更多示例

在树梅派的 Github [仓库](https://github.com/raspberrypi/linux/tree/rpi-4.4.y/arch/arm/boot/dts/overlays)中有大量持续更新的覆盖源码文件可供参考。

## 第三部分：在树梅派中使用设备树

### 3.1：覆盖和 config.txt

### 3.2：设备树参数

### 3.3：板级标签与参数

### 3.4：HAT 与设备树

### 3.5：动态设备树

#### 3.5.1：dtoverlay 命令
#### 3.5.2：dtparam 命令
#### 3.5.3：运行时覆盖指南
#### 3.5.4：特别提醒

### 3.6：更多关于覆盖与参数